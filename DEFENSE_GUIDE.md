# 🚀 SmartTodo 项目验收全攻略 (6人防御版)

> **致全体组员**：明天就是验收的日子。这份文档总结了我们的分工、技术栈及核心逻辑。请大家务必花 5 分钟阅读，确保老师提问时我们能对答如流。

---

## 📅 一、 6 人分工表 (软件工程角色分配)

为了符合软工规范，我们将项目分为需求、设计、开发、测试、运维五个阶段：

1.  **同学 A (产品经理)**
    *   **职责**：需求分析与原型设计、PPT 制作、汇报演示。
    *   **交付物**：需求规格说明书 (SRS)、演示文稿。
2.  **同学 B (你 - 首席架构师)**
    *   **职责**：核心业务逻辑、DeepSeek AI 集成架构、Prompt Engineering (提示词工程)。
    *   **交付物**：`TaskProcessor` 与 `DeepSeekHelper` 核心模块代码。
3.  **同学 C (前端开发工程师)**
    *   **职责**：基于 Jetpack Compose 的响应式 UI 开发、交互逻辑实现。
    *   **交付物**：`ui/components` 目录下的所有组件及任务列表界面。
4.  **同学 D (数据架构工程师)**
    *   **职责**：Room 数据库设计、数据持久化策略、DAO 接口编写。
    *   **交付物**：`data/` 目录下的数据库架构及实体类定义。
5.  **同学 E (系统集成工程师)**
    *   **职责**：Android 系统级服务对接 (Notification Listener)、权限生命周期管理。
    *   **交付物**：`MyNotificationService` 及通知拦截逻辑实现。
6.  **同学 F (QA 测试与文档工程师)**
    *   **职责**：功能压力测试、UML 类图/时序图绘制、技术文档汇总。
    *   **交付物**：测试报告、系统架构 UML 图。

---

## 🛠️ 二、 我们的“技术黑话” (技术栈)

如果老师问“用了什么技术？”，请记住以下关键词：

*   **UI 层**：**Jetpack Compose** (Android 官方推荐的声明式 UI 框架，非传统 XML)。
*   **架构模式**：**MVVM** (Model-View-ViewModel)，通过 `SmartTodoViewModel` 实现数据与 UI 的解耦。
*   **异步处理**：**Kotlin Coroutines (协程)**，用于非阻塞式的 AI 请求和数据库操作。
*   **本地存储**：**Room Persistence Library** (基于 SQLite 的 ORM 框架)。
*   **AI 核心**：**DeepSeek-V3 API**，采用 **JSON Mode** 强约束输出，确保语义解析的稳定性。
*   **通知拦截**：**NotificationListenerService**，Android 系统提供的底层通知监听接口。

---

## 🧠 三、 核心逻辑流程 (防挂点必读)

**老师提问：消息是怎么自动变成待办任务的？**

1.  **抓取**：用户手机收到一条微信消息，我们的 `MyNotificationService` 实时捕获文本内容。
2.  **入库**：消息先存入数据库的“原始消息表” (RawMessage)，作为后续 AI 分析的证据。
3.  **分析**：系统调用 `TaskProcessor`。它不是简单地分析这一条消息，而是把这条消息和数据库里已有的任务一起发给 AI。
4.  **智能决策**：AI (DeepSeek) 会判断这是“新任务”、“旧任务的更新”还是“垃圾信息”。
5.  **反馈**：AI 返回 JSON 数据，系统自动创建或更新 `SmartTask`，UI 通过 `Flow` 数据流自动刷新显示。

---

## ❓ 四、 常见问题预演 (Q&A)

*   **Q：为什么不用正则表达式解析？**
    *   **A**：正则只能匹配固定格式。但用户的聊天很随意（如“帮我记一下明天的会”），只有大语言模型能理解上下文语义并自动提取时间、地点和子任务。
*   **Q：AI 反应慢怎么办？**
    *   **A**：我们使用了协程异步处理，并在 UI 上提供了 `isProcessing` 状态反馈。分析过程在后台进行，不影响用户正常浏览任务列表。
*   **Q：如果 AI 解析错了怎么办？**
    *   **A**：我们设计了“草稿确认”机制。AI 解析后的任务默认是 `isDraft = true` 状态，用户可以手动修改或点击确认后才正式生效。

---

## 🛡️ 六、 个人“保命”话术与核心理解 (详细版)

### 1. 同学 A (组长 / 产品经理) —— “项目的灵魂”
**你要明白的直白逻辑：**
*   **痛点**：现在人每天微信消息太多，很多事（比如“明天交表”、“下午开会”）转头就忘。手动复制到备忘录太麻烦。
*   **我们的方案**：手机收到通知，AI 自动帮你记下来。你只需要看一眼、点一下确认就行。
*   **你的核心话术**：
    *   “我们关注的是**碎片化信息的自动化处理**。用户不需要改变使用习惯，系统在后台静默工作。”
    *   “产品设计的核心是**‘最小化人工干预’**，让 AI 变成人的第二个大脑。”
*   **如果老师问“竞品（如系统自带待办）有什么区别？”：**
    *   答：系统待办需要你手动输入。我们的产品是**“消息驱动”**的，是主动抓取并理解语义，比它们多了一个“大脑”。

### 2. 同学 B (首席架构师) —— “技术定海神针”
**你要明白的直白逻辑：**
*   **AI 怎么调用的**：用的是 OkHttp 调 DeepSeek 的 API。关键在于我们传过去的 `Prompt` (提示词)，我们命令 AI 必须返回 JSON 格式，否则代码没法解析。
*   **任务怎么处理的**：有一个 `TaskProcessor` 单例，它像个流水线。消息进来 -> 存数据库 -> 调 AI -> 更新数据库。
*   **你的核心话术**：
    *   “我们实现了**基于提示词工程 (Prompt Engineering) 的强约束输出**，解决了大模型输出不稳定的问题。”
    *   “架构上采用了**状态机思想**，消息从 RECEIVED 到 PROCESSING 再到 PROCESSED，全流程可追溯。”
*   **如果老师问“为什么选 DeepSeek？”：**
    *   答：它的 V3 模型在指令遵循（尤其是 JSON 格式输出）和中文语义理解上性价比最高，适合移动端轻量级调用。

---

### 3. 同学 C (UI 开发工程师) —— “门面担当”
**你要明白的直白逻辑：**
*   **界面是怎么写的**：没用传统的布局文件，全是用 Kotlin 代码写的（Jetpack Compose）。这样写 UI 很快，而且方便做动画。
*   **界面为什么会变**：用了 `StateFlow`。简单说，就是 UI 订阅了数据库的“广播”，数据库里的任务一变，UI 就像刷朋友圈一样自动刷出来。
*   **你的核心话术**：
    *   “我们采用了**响应式 UI 编程模型**。UI 只是状态的反映，不需要手动调用 `notifyDataSetChanged`。”
    *   “通过 **Material Design 3** 规范封装了通用的 `TaskCard` 和 `StatusBadge` 组件，保证了视觉的一致性。”
*   **如果老师问“怎么处理列表加载卡顿？”：**
    *   答：我们使用了 `LazyColumn`（相当于高级版 RecyclerView），它只会渲染屏幕内可见的卡片，性能非常丝滑。

---

### 4. 同学 D (数据架构工程师) —— “账本管家”
**你要明白的直白逻辑：**
*   **数据存在哪**：存在手机本地的 SQLite 数据库里，外面包了一层叫 `Room` 的框架。
*   **核心表结构**：有两张主表。一张存原始消息（谁发的、内容是什么），另一张存 AI 提炼出来的任务（标题、时间、是否完成）。
*   **你的核心话术**：
    *   “数据库设计遵循了**范式要求**，通过 `taskId` 建立了原始消息与智能任务的一对多关联。”
    *   “使用了 **Room 的 Flow 异步查询机制**，确保数据库读写操作永远不会阻塞主线程。”
*   **如果老师问“数据安全怎么考虑？”：**
    *   答：目前数据全部存储在本地私有目录，不上传服务器（除了调 AI 的脱敏文本），最大限度保护了用户隐私。

---

### 5. 同学 E (系统集成工程师) —— “情报特工”
**你要明白的直白逻辑：**
*   **怎么拿到微信消息的**：用了 Android 系统的 `NotificationListenerService`。这就像是在系统里装了个“监听器”，只要有新通知弹出，系统就会告诉我们。
*   **权限问题**：这需要用户手动去设置里打开“通知使用权”，否则 App 抓不到任何东西。
*   **你的核心话术**：
    *   “我们通过继承 `NotificationListenerService` 实现了**非侵入式的消息抓取**，不需要 Root 权限，符合 Android 安全规范。”
    *   “针对不同 App 的通知格式做了**适配清洗**，过滤了系统通知等杂讯，只保留有价值的即时通讯消息。”
*   **如果老师问“后台进程被杀了怎么办？”：**
    *   答：我们使用了 Android 的 **Service 生命周期保护机制**，并建议用户将 App 加入电池优化白名单，以维持后台监听的稳定性。

---

### 6. 同学 F (QA 测试与文档) —— “质量守门员”
**你要明白的直白逻辑：**
*   **怎么测试的**：我们模拟了各种奇葩消息（比如全是乱码、或者只有表情），看 AI 会不会崩，结果发现 AI 会返回 `IGNORE`（忽略），程序很稳。
*   **文档里写了啥**：写了整个软件的流程图。从收到通知到显示任务，每一步都有据可查。
*   **你的核心话术**：
    *   “我们进行了**黑盒测试与边界值分析**，特别验证了网络断开、API Key 失效等极端情况下的容错处理。”
    *   “利用工具生成了**系统类图与时序图**，清晰地展示了 `UI -> ViewModel -> Logic -> DB` 的调用链路。”
*   **如果老师问“你们发现了什么 Bug？”：**
    *   答：在测试初期发现 AI 偶尔会返回非 JSON 格式的废话，后来我们通过**提示词调优 (Prompt Tuning)** 解决了这个鲁棒性问题。

---

## 💡 七、 验收小贴士

1.  **演示准备**：在“设置”里配好 API Key。找两台手机或自发消息，演示“收到通知 -> 自动生成任务”的全过程。
2.  **强调原创思考**：虽然我们用了 AI 辅助开发，但 **“提示词工程 (Prompt Engineering)”** 和 **“消息驱动的任务管理模型”** 是我们团队的核心设计思想。
3.  **心态平和**：老师主要看你们对软工流程的理解。只要分工明确、逻辑闭环，就是一个优秀的课设！

---
祝大家明天验收顺利，全组高分过关！加油！💪
